<!--
  <details>
    <summary></summary>
  </details>
-->

## 프로세스 & 스레드 기초

<details>
  <summary><b>프로세스가 무엇인가요?</b></summary>

  - 메인 메모리에 올라가 실행 중인 프로그램을 의미합니다.
  - 따라서, 다른 프로세스 자원에 접근 시, 프로세스 간 통신(IPC)을 사용해야 합니다.
  - 이 프로세스는 각각 Code, Data, Stack, Heap 구조로 되어있는 독립된 메모리 영역을 할당 받고 최소 하나 이상의 스레드로 구성되어 있습니다.
    - 코드/텍스트 영역 : 컴파일된 소스 코드가 저장되는 영역
    - 데이터 영역 : 전역변수 및 초기화된 데이터가 저장되는 영역
    - 스택 영역 : 임시 데이터(함수 호출, 로컬 변수 등)가 저장되는 영역
    - 힙 영역 : 코드에서 동적으로 생성되는 데이터가 저장되는 영역
  
   ---

  <details>
    <summary>프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.</summary>

    - 프로세스
      - 프로세스는 프로그램 실행 시, 운영체제로부터 실행에 필요한 자원을 할당 받습니다.
      - 즉, 프로그램은 파일이 저장장치에 저장되어 있지만, 메모리엔 올라가지 않은 정적 상태이고,
        이런 프로그램을 실행시켜 운영체제로부터 CPU를 할당받아 실행되는 상태가 바로 프로세스라고 합니다.
      - 프로세스는 독립된 메모리를 할당받기 때문에, IPC를 사용해서 다른 프로세스 자원에 접근할 수 있습니다.
    - 스레드
      - 스레드는 프로세스가 할당 받은 자원을 이용하는 실행 단위입니다.
      - 각 스레드는 독자적인 Stack과 Register를 갖고 있고 프로세스의 Code, Data, Heap 영역을 공유합니다.
      - 즉, 스레드는 메모리를 공유하기 때문에, 동기화, 데드락 등의 문제가 발생할 수 있습니다.
  </details> 
  <details>
    <summary>PCB(Process Control Block)가 무엇인가요?</summary>

    - 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말합니다.
    - 즉, 프로세스가 생성되면 운영체제는 해당 PCB를 생성하고 프로세스 완료 시, PCB는 제거됩니다.
    - 이곳에는 프로세스 ID, 프로그램 카운터, CPU 레지스터, 프로세스 상태 등이 저장되어 있습니다.
    - PCB는 Context Switching에 사용되기도 합니다.
  </details> 
  <details>
    <summary>그렇다면, 스레드는 PCB를 갖고 있을까요?</summary>

    - 스레드는 프로세스 내부에 있으므로 PCB를 가지지 않고 TCB를 가집니다.
  </details> 
  <details>
    <summary>리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</summary>

    - 프로세스
      - fork() 함수를 통해 주소 공간을 그대로 복사하여 자식 프로세스를 생성할 수 있습니다.
      - exec() 함수를 통해 해당 자식 프로세스를 다른 작업으로 변경할 수 있습니다.
    - 스레드
      - POSIX의 pthread_create()를 통해 생성할 수 있습니다.
  </details> 
  <details>
    <summary>자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</summary>

    - 부모 프로세스가 아직 wait()를 호출하지 못한 상태로 자식 프로세스가 죽을 때,
      - 이때 자식 프로세스가 종료되어도, 해당 프로세스의 PCB는 커널 내에 여전히 남아 있지만 더 이상 실행되지 않습니다.
      - 즉, 좀비 프로세스가 됩니다. 이 좀비 프로세스가 쌓이면 결국 자원 낭비를 야기하게 됩니다.
      - 하지만, 커널은 자식 프로세스가 종료되어도 최소한 정보(프로세스 ID, 프로세스 종료 상태 등)을 유지하고 있기 때문에,
        이 정보를 부모 프로세스가 wait()을 통해 확인할 수 있어서 부모 프로세스가 wait()를 호출하면 좀비 프로세스는 없어집니다.
    - 부모 프로세스가 먼저 죽을 때,
      - 이때는 자식 프로세스가 고아 프로세스가 됩니다. 이 고아 프로세스는 부모 프로세스가 없으므로, 
        부모 프로세스가 이들의 종료 상태를 확인하거나 회수할 수 없습니다.
      - 이 경우에는 리눅스 시점에서 init 프로세스가 부모 프로세스가 되어 고아 프로세스들을 관리합니다.
      - 즉, init 프로세스가 주기적으로 wait()을 호출함으로 써 고아 프로세스의 자원을 회수합니다.
  </details> 
  <details>
    <summary>리눅스에서, 데몬 프로세스에 대해 설명해 주세요.</summary>

    - 데몬 프로세스는 특정한 시스템 작업이나 서비스를 제공하는 프로세스입니다. 
      이러한 데몬 프로세스들은 사용자와 상호작용하지 않고, 주로 시스템의 특정 기능을 계속해서 실행하거나 관리하는 데 사용됩니다.
    - 데몬은 항상 백그라운드로 실행되는 프로세스이며, 대부분 부팅 시에 자동으로 시작되고 시스템 종료 전가지 실행될 수 있습니다.
    - 특징
      - 백그라운드에서 실행 : 데몬 프로세스는 사용자와 직접적으로 상호작용하지 않고, 시스템 서비스를 제공하기 위해 백그라운드에서 실행
      - 주기적인 서비스 제공 : 데몬은 주기적으로 시스템 작업을 수행하거나 특정 서비스를 제공
        - Ex: 웹 서버의 데몬 : 웹 페이지 요청을 수신
        - Ex: 파일 서버의 데몬 : 파일을 전송 및 수신
      - 시스템 리소스 관리 : 데몬은 종종 시스템 리소스를 관리하고, 백업, 로깅, 네트워크 통신 등과 같은 시스템 작업을 수행
      - 무한 루프 실행 : 대부분의 데몬은 무한 루프를 실행하여 지속적으로 요청을 처리하거나 시스템을 모니터링
      - init 프로세스의 자식 : 대부분의 데몬은 init 프로세스의 자식 프로세스로 시작. 즉, 시스템 부팅 시, init 프로세스에 의해 시작되고 관리
    - 대표적인 데몬 프로세스 예시
      - 웹 서버, 네트워크 서비스, 로깅 서비스 등이 있습니다.
  </details> 
  <details>
    <summary>리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.</summary>

    - UNIX에서는 init 프로세스라고 불리며 부팅 시 첫 번째로 생성되는 프로세스입니다. 
    - 리눅스에서도 이 방식을 가져왔으며 최근에는 systemd라고 이름을 붙입니다. 
    - PID는 항상 1이며 모든 프로세스의 부모이기도 합니다. 
  </details> 

  ---
</details>

<details>
  <summary><b>프로세스 주소공간에 대해 설명해 주세요.</b></summary>

  - 이는 주소 공간은 실행 중인 각 프로세스에 할당된 메모리 공간을 의미하는 것으로 고유한 주소 공간을 가집니다.
  - 이 주소 공간은 프로세스가 실행되는 동안 프로그램 코드, 데이터, 스택, 힙 등의 요소들을 포함합니다.
    - 코드/텍스트 영역: 프로그램의 명령어가 저장되는 영역
    - 데이터 영역: 전역 변수와 정적 변수가 저장되는 영역
    - 힙 영역: 동적 할당을 통해 생성된 변수나 객체가 저장되는 영역
    - 스택 영역: 함수의 호출 정보와 지역 변수가 저장되는 영역

  ---
  
  <details>
    <summary>초기화 하지 않은 변수들은 어디에 저장될까요?</summary>

    - 데이터 영역에 저장됩니다.
      - 이 외에도 전역변수, Static 변수를 저장합니다.
      - 프로그램이 시작될 때, 고정도니 사이즈를 처음부터 종료까지 유지합니다.
  </details> 
  <details>
    <summary>Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?</summary>

    - 접근 속도가 더 빠른 공간은 일반적으로 Stack 영역입니다.
    - 스택은 메모리 상에 연속적으로 배치되어 CPU 캐시의 지역성을 잘 활용할 수 있기 때문입니다.
    - 반면 힙은 메모리 블록들이 흩어져 있을 수 있어 단편화 문제가 발생하고 이는 메모리 관리에 추가적인 오버헤드가 발생합니다.
  </details> 
  <details>
    <summary>다음과 같이 공간을 분할하는 이유가 있을까요?</summary>

    - 각 역할을 분배하고 데이터를 공유하여 메모리 사용량을 줄이기 위함이라 생각합니다.
      - 스택 영역
        - LIFO(후입선출) 구조를 이용해 함수 호출과 지역변수 관리가 쉽도록 설계되어 빠른 호출과 반환 작업이 가능합니다.
        - 구조화된 형태와 고정된 할당 패턴은 메모리 조각화와 할당 관련 문제를 예방하는 데 도움됩니다.
        - 스택은 작고 메모리 엑세스 패턴이 예측 가능하기 때문에, 캐시에 저장해두고 쓰기 좋습니다.
          즉 스택에 저장된 데이터는 프로세서의 캐시에 더 자주 존재하므로 메모리 엑세스 시간이 더 빠릅니다.
      - 힙 영역
        - 한 번의 함수 호출 범위를 넘어 지속되어야 하는 경우 동적 수명을 갖는 데이터를 관리하기 위해 필요합니다.
        - 힙을 사용하면 데이터를 구조화되지 않은 방식으로 할당/해제할 수 있으므로 
          다양한 크기의 데이터 구조를 관리하는 데, 유연성을 제공합니다.
      - 코드/텍스트 영역
        - 같은 프로그램에선 모두 같은 내용이기 때문에, 따로 관리하여 공유합니다.
        - 기계어만 들어있기 때문에, 다른 영역과 분리하는게 당연하다고 생각합니다.
      - 스택/데이터 영역
        - 스택 구조의 특성과 전역변수의 활용성을 위해 분리되었다고 생각합니다.
        - 스택 영역을 통해 함수의 흐름을 관리합니다.
        - 데이터 영역을 통해 전역 변수와 Static 변수를 관리합니다.
        - 각 스레드는 독립된 Stack 영역을 갖지만 Data 영역은 공유합니다. 
          즉, 각 스레드가 동일한 Data 공유함으로써 메모리를 절약할 수 있습니다.        
  </details> 
  <details>
    <summary>스레드의 주소공간은 어떻게 구성되어 있을까요?</summary>

    - 스레드는 프로세스 내에서 독립된 스택 영역을 할당받고 나머지 영역은 공유합니다.
    - 때문에, Data 영역에 있는 자원인 공유 데이터는 동시에 여러 스레드가 접근할 수 있어서 동기화가 필요합니다.
  </details> 
  <details>
    <summary>IPC(Inter-Process Communication)의 Shared-Memory기법은 프로세스 주소공간의 어디에 들어가고 그 이유는?</summary>

    - 이는 프로세스 주소 공간의 힙 영역에 들어갑니다.
      - 힙 영역은 프로세스 간 동적으로 할당된 데이터를 쉽게 공유할 수 있으며 스레드 또한 공유할 수 있기 때문입니다.
      - 힙 영역은 동적 메모리 할당에 사용되므로 공유 메모리를 위한 메모리를 할당하는 데 사용할 수 있기 때문입니다.
    - IPC
      - 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
    - Shared Memory
      - 두 개 이상의 프로세스가 동일한 메모리 공간을 공유하는 기법
  </details>  
  <details>
    <summary>스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?</summary>

    - 스택과 힙 영역의 크기는 런타임에 결정됩니다. 즉, 실행 중 동적으로 크기가 필요에 따라 변합니다.
    - 때문에, 프로그램 개발자가 아닌 사용자가 이 공간의 크기를 수정하는 것은 어렵다고 생각합니다.
  </details>  
  <details>
    <summary>Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? </summary>

  ![image](https://github.com/HyuckJuneHong/Tech-Interview/assets/31675711/59ce628c-f4c4-4a05-8f17-9b234f989fb5)

    - 일반적으로 매우 크다고 단정 짓기는 어렵다고 생각합니다.

    - 스택
      - 실제 객체는 Heap 영역에서 관리되고 스택에서 참조를 갖기 때문에 Stack은 클 필요가 없습니다.
      - 힙 영역과는 상관없이 크기에 제한을 갖기 때문에, 재귀 함수가 깊어지거나 지역변수를 많이 가지면 스택 오버플로우가 발생합니다.
    - 힙
      - 스택보다는 할당할 수 있는 메모리 공간이 크다.
      - 가변적 크기를 가진다.
  </details> 
  <details>
    <summary>"스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있을까요?</summary>

    - 실제로 관련이 있다고 생각합니다.

    - 스택
      - 자료구조
        - 후입선출(LIFO) 원칙을 따르는 데이터 구조
        - Push와 Pop이 주요 작업
      - 운영체제
        - 함수 호출과 지역 변수에 사용되는 메모리 영역
        - 함수 호출 시, 새로운 스택 프레임에 Push되고 함수 반환시 스택 프레임이 Pop되며 제어가 호출한 함수로 돌아간다.
    - 힙
      - 자료구조
        - 각 노드가 자식 노드를 가리키는 트리와 유사한 구조로 구현
        - 삽입, 삭제와 같은 작업을 지원하여 메모리 할당/해제를 효율적으로 관리
      - 운영체제
        - 동적 메모리 할당에 사용되는 메모리 영역을 의미
        - 프로그램은 malloc() 또는 new 등과 같은 함수를 사용해 런타임에 메모리를 요청
  </details> 
  
  ---
</details>
<details>
  <summary><b>컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?</b></summary>

  ---

  - 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
  - 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
  - 컨텍스트 스위칭은 언제 일어날까요?

  ---
</details>
<details>
  <summary><b>IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.</b></summary>

  ---

  - Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.
  - 메시지 큐는 단방향이라고 할 수 있나요?

  ---
</details>

## 시스템 콜 & 인터럽트 & 스케줄러

<details>
  <summary><b>시스템 콜이 무엇인지 설명해 주세요.</b></summary>

  - OS는 다양한 서비스들을 수행하기 위해 하드웨어를 직접 관리하고 <br/>
    응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있습니다. <br/>
    이때, OS가 제공하는 인터페이스를 시스템 콜이라 합니다.
  - 시스템 콜은 커널 영역의 기능을 사용자 모드가 사용 가능하게 해줍니다. <br/>
    즉, 프로세스가 하드웨어에 접근해서 필요한 기능을 할 수 있게 해줍니다.
  - 이 시스템콜은 보통 사용자가 직접 호출하기 보단 API를 통해 접근합니다.

  ---

  <details>
    <summary>우리가 사용하는 시스템 콜의 예시를 들어주세요. </summary>
    
    - 흔히 사용하는 시스템 콜로는 파일을 열거나 닫는 'open', 'close', 
    - 프로세스를 생성하거나 종료하는 'fork', 'exit', 
    - 메모리를 할당하거나 해제하는 'malloc', 'free' 등이 있습니다.
  </details>  
  <details>
    <summary>시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요. </summary>

    1. 사용자 프로세스가 시스템 콜을 호출하면, trap이 걸리면서 mode bit 값이 1에서 0으로 바뀝니다. 즉, 유저모드에서 커널모드가 됩니다.
    2. 이때, 커널은 내부적으로 시스템 콜을 구분하기 위해 기능별로 고유 번호를 할당하고 해당 번호에 제어 루틴의 정의하고 있기 때문에,
       커널은 요청받은 시스템 콜에 대응하는 고유 번호를 확인하고 그에 맞는 서비스 루틴을 호출합니다.
    3. 작업 완료 후 다시 사용자 모드로 전환됩니다. 즉, mode bit도 0에서 1로 바뀝니다.
  </details>  
  <details>
    <summary>시스템 콜의 유형에 대해 설명해 주세요.</summary>

    - 프로세스 제어, 파일 조작, 장치 관리, 정보 유지, 통신이 있습니다.
  </details>  
    <details>
    <summary>운영체제의 Dual Mode 에 대해 설명해 주세요.</summary>

    - 운영체제는 사용자 모드, 커널 모드로 나뉘어 동작하고 이를 Dual Mode Operation이라 합니다.
    - 이때, 유저모드와 커널모드를 구분하는 이유는 시스템을 보호하기 위해서 입니다. 
      즉, 의도치 않거나 악의적으로 호출을 막아 시스템 내부 데이터를 보호합니다.
    - 예를 들어, 사용자 모드는 접근할 수 있는 메모리 영역이 사용자에게 허용된 정도로 제한되어 있고 하드웨어에 직접적으로 접근할 수 없습니다.
    - 반면, 커널 모드는 모든 시스템 메모리와 CPU Instruction, 하드웨어에 직접적으로 접근할 수 있습니다.
  </details> 
  <details>
    <summary>왜 유저모드와 커널모드를 구분해야 하나요? (답변 미작성)</summary>
  </details>  
  <details>
    <summary>서로 다른 시스템 콜을 어떻게 구분할 수 있을까요? (답변 미작성)</summary>
  </details>  

  ---
</details>

<details>
  <summary><b>인터럽트가 무엇인지 설명해 주세요.</b></summary>

  - 인터럽트는 프로그램 실행 도중에 예기치 않은 상황이나 급한 작업이 발생할 경우, <br/>
    현재 실행 중인 작업을 일시 중단 후, 발생된 상황을 우선처리한 후 실행 중이던 작업으로 복귀해 계속 처리하는 것을 말합니다.

  ---
  
  <details>
    <summary>인터럽트는 어떻게 처리하나요?</summary>

    1. HW 혹은 SW 이벤트에 의해, 인터럽트 요청 시, CPU가 현재 실행 중인 프로세스를 중단하고 PCB에 해당 작업 상태를 저장합니다.
    2. 이후 ISR(인터럽트 서비스 루틴) 주소 값을 얻기 위해, Interrupt Vector 테이블을 참조합니다.
      - ISR(인터럽트 핸들러, 인터럽트 서비스 루틴) : 해당 인터럽트를 처리하기 위한 코드 집합입니다.
      - 이때, ISR 내에서 다른 인터럽트가 발생하지 않도록 인터럽트 플래그를 사용해 중첩된 인터럽트를 방지합니다.
    3. 서비스 루틴을 수행할 때, 우선순위가 더 높은 인터럽트 발생 시, 재귀적으로 과정을 수행합니다.
    4. 루틴 수행이 끝나면 상태 복구 명령어가 실행되어 저장해둔 PCB 등을 복원하고 CPU는 중단되었던 프로세스 실행을 재개합니다.
  </details>  
  <details>
    <summary>Polling 방식에 대해 설명해 주세요.</summary>
    
    - 폴링은 특정 주기를 갖고 해당 주기마다 처리를 위한 시그널이 들어왔는지 체크합니다.
    - 따라서 커널과 같은 인터럽트 핸들러가 필요하지 않습니다.
    - 단, 시스템 리소스를 많이 소비하기 때문에 구현 시, 시스템의 성능 저하 원인이 되기도 합니다.
  </details>  
  <details>
    <summary>HW / SW 인터럽트에 대해 설명해 주세요.</summary>

     - HW 인터럽트 (=외부 인터럽트)
       - 일반적으로 하드웨어에서 발생하는 인터럽트를 말합니다.
       - Ex) 전원의 이상, CPU의 기능, 기계의 착오, 키보드 동작, 입출력 장치의 데이터 전송 등
     - SW 인터럽트 (=내부 인터럽트)
       - Trap이라고도 하며 프로그램 내부에서 발생하는 것을 말합니다.
       - Ex) 잘못된 명령, 잘못된 데이터 사용 등
  </details>  
  <details>
    <summary>동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?</summary>

    - 운영체제에서 사용되는 인터럽트 처리 메커니즘에 따라 정확한 동작이 달라질 수 있지만 주로 아래와 같이 동작합니다.
      - 인터럽트 우선순위 할당 : 가장 높은 우선순위를 가진 인터럽트를 처리합니다.
      - 인터럽트 마스킹 : 인터럽트 처리 중 다른 인터럽트를 일시적으로 비활성화하여 우선순위를 선점하지 못하도록 방지할 수 있습니다.
      - 인터럽트 큐, 버터 : 받은 순서대로 대기 중인 인터럽트를 처리하고 처리 순서를 관리합니다.
  </details>

  ---
</details>
<details>
  <summary><b>단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.</b></summary>

  ---

  - 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?
  - 프로세스의 스케쥴링 상태에 대해 설명해 주세요.
  - preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
  - Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

  ---
</details>

<details>
  <summary><b>프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?</b></summary>

  ---

  - RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
  - 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
  - 동시성과 병렬성의 차이에 대해 설명해 주세요.
  - 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?
  - FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요? 
  - 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
  - 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

  ---
</details>

## Reference

- [스택이 왜 힙보다 빠르다고 하는 걸까?](https://arca.live/b/programmer/67268686)



<!--
## 프로세스 & 스레드 심화

<details>
  <summary><b>8. 뮤텍스와 세마포어의 차이점은 무엇인가요?</b></summary>

  - 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.
  - Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요? 
  - 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

</details>

<details>
  <summary><b>9. Deadlock 에 대해 설명해 주세요.</b></summary>

  - Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.
  - 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?
  - 어떤 방식으로 예방할 수 있을까요?
  - 왜 현대 OS는 Deadlock을 처리하지 않을까요?
  - Wait Free와 Lock Free를 비교해 주세요.

</details>

<details>
  <summary><b>10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.</b></summary>

  - 링커와, 로더의 차이에 대해 설명해 주세요.
  - 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.
  - JIT에 대해 설명해 주세요.
  - 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.
  - Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?
  - 우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?

</details>

<details>
  <summary><b>12. Thread Safe 하다는 것은 어떤 의미인가요?</b></summary>

  - Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?
  - Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.
  - Race Condition 이 무엇인가요?
  - Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?

</details>

<details>
  <summary><b>13. Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.</b></summary>

  - Thread Pool을 사용한다고 가정하면, 어떤 기준으로 스레드의 수를 결정할 것인가요? 
  - 어떤 데이터를 정렬 하려고 합니다. 어떤 방식의 전략을 사용하는 것이 가장 안전하면서도 좋은 성능을 낼 수 있을까요?

</details>

## 메모리

<details>
  <summary><b>14. 캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.</b></summary>

  - 캐시 메모리는 어디에 위치해 있나요?
  - L1, L2 캐시에 대해 설명해 주세요.
  - 캐시에 올라오는 데이터는 어떻게 관리되나요?
  - 캐시간의 동기화는 어떻게 이루어지나요?
  - 캐시 메모리의 Mapping 방식에 대해 설명해 주세요.
  - 캐시의 지역성에 대해 설명해 주세요.
  - 캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.
  - 캐시의 공간 지역성은 어떻게 구현될 수 있을까요? (힌트: 캐시는 어떤 단위로 저장되고 관리될까요?) 

</details>

<details>
  <summary><b>15.메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)</b></summary>

  - worst-fit 은 언제 사용할 수 있을까요?
  - 성능이 가장 좋은 알고리즘은 무엇일까요?

</details>

<details>
  <summary><b>16. Thrashing 이란 무엇인가요?</b></summary>

  - Thrashing 발생 시, 어떻게 완화할 수 있을까요?

</details>

<details>
  <summary><b>17. 가상 메모리란 무엇인가요?</b></summary>

  - 가상 메모리가 가능한 이유가 무엇일까요?
  - Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.
  - 페이지 크기에 대한 Trade-Off를 설명해 주세요.
  - 페이지 크기가 커지면, 페이지 폴트가 더 많이 발생한다고 할 수 있나요?
  - 세그멘테이션 방식을 사용하고 있다면, 가상 메모리를 사용할 수 없을까요?


</details>

<details>
  <summary><b>18. 세그멘테이션과 페이징의 차이점은 무엇인가요?</b></summary>

  - 페이지와 프레임의 차이에 대해 설명해 주세요.
  - 내부 단편화와, 외부 단편화에 대해 설명해 주세요.
  - 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.
  - 어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?
  - 32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?
  - 32비트 운영체제는 램을 최대 4G 까지 사용할 수 있습니다. 이 이유를 페이징과 연관 지어서 설명해 주세요.
  - C/C++ 개발을 하게 되면 Segmentation Fault 라는 에러를 접할 수 있을텐데, 이 에러는 세그멘테이션/페이징과 어떤 관계가 있을까요?  

</details>

<details>
  <summary><b>19. TLB는 무엇인가요?</b></summary>

  - TLB를 쓰면 왜 빨라지나요?
  - MMU가 무엇인가요?
  - TLB와 MMU는 어디에 위치해 있나요?
  - 코어가 여러개라면, TLB는 어떻게 동기화 할 수 있을까요? 
  - TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요. 

</details>

<details>
  <summary><b>20. 동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.</b></summary>

  - volatile 키워드는 어떤 의미가 있나요?
  - 싱글코어가 아니라 멀티코어라면, 어떻게 동기화가 이뤄질까요?
  - 

</details>

<details>
  <summary><b>21. 페이지 교체 알고리즘에 대해 설명해 주세요.</b></summary>

  - LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?
  - LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?
  - LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.

</details>

<details>
  <summary><b>22. File Descriptor와, File System에 에 대해 설명해 주세요.</b></summary>

  - I-Node가 무엇인가요?
  - 프로그래밍 언어 상에서 제공하는 파일 관련 함수 (Python - open(), Java - BufferedReader/Writer 등)은, 파일을 어떤 방식으로 읽어들이나요?

</details>

<details>
  <summary><b>23. 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.</b></summary>

  - 그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?
  - I/O 멀티플렉싱에 대해 설명해 주세요.
  - 논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요? 

</details>
-->
